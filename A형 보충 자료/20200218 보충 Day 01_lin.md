# 20200218 보충 Day 01

보충 시간에 할 것:

- 백준에 있는 문제집 중 삼성 SW 역량 테스트 기출 문제를 풀 예정
- BFS를 사용하는 문제는 뒤 쪽으로 뺄 예정



## 17135. 캐슬 디펜스

https://www.acmicpc.net/problem/17135

### 문제 설명

- 적이 아래로 내려오는 상황이며, 성은 맨 아래쪽 (N+1)에 위치한다.

```python
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
*CASTLE*
```

- 궁수는 3명을 배치하고, 1칸에 최대 1명의 궁수를 배치시킨다.

```
N = 5 일 때, 여기서 1은 궁수의 위치를 말한다.
하단은 궁수를 배치할 수 있는 경우의 수 이다.
1 1 1 0 0
1 1 0 0 1
1 1 0 1 0
1 0 1 1 0
1 0 1 0 1
1 0 0 1 1
0 0 1 1 1
0 1 1 1 0
0 1 1 0 1
0 1 0 1 1

위와 같이 다양한 방식으로 궁수를 배치할 수 있다.
```

- 거리는 두 위치 (r1, c1), (r2, c2)를 기반으로 |r1-r2| + |c1-c2| 이다.
  - 거리가 같다면 가장 왼쪽의 적을 공격한다.

- 공격을 받은 적은 격자판에서 지워진다.

- 공격이 끝나면, 적들이 성 쪽으로 한 줄 내려온다.

- 성 쪽으로 적들이 내려온다면 격자판에서 지워지고, 모든 적들이 없어진다면 게임이 끝난다.



### 문제 접근 방식

- 궁수의 위치를 선정하는 방법
  - 조합, 순열 부분집합
- 적을 공격하는 과정과 없애는 과정
  - 계산을 통해 완전탐색



### 문제 접근하기

#### 궁수의 위치 선정

세 궁수의 위치를 i, j, k로 얘기하자.

m은 열의 수이다.

i 의 범위는 0부터 m-3까지의 위치를 말한다.

j의 범위는 i + 1부터 m-2 까지의 위치를 말한다.

k의 범위는 j + 1부터 m-1 까지의 위치를 말한다.

```python
for i in range(m-2): #첫 궁수의 위치: #m-3까지이기 때문에 m-3을 포함해 m-2라 한다.
    for j in range(i+1, m-1): #두 번째 궁수 위치
        for k in range(j+1, m): #세 번째 궁수 위치
            defense(i, j, k) #공격을 시행한다.

```



#### 거리 고려하기

```
숫자는 궁수와의 거리를 뜻한다.
별표(*)는 궁수의 위치를 뜻한다.

0 0 3 0 0
0 3 2 3 0
3 2 1 2 3
- - * - -
```



최소 거리를 확인하고, 거리가 같으면 왼쪽 궁수를 찾는다.

```
D = 3 (최대 거리 3까지 적을 공격할 수 있다.)
0 0 0 0 0
0 0 3 0 0 
0 1 0 1 0
- * - * -
궁수의 위치가 위와 같을 때, 둘 다 3의 위치를 공격한다.
```

1. 어떤 적이 공격에 맞았는지 기록해도 된다.
2. 화살에 맞을 때마다 공격한 적을 +1 을 한다. 화살을 여러 번 맞은 아이는, 칸의 값이 1 이상이라면 이미 맞았다는 것을 구분하고, 값이 2 이상인 것을 지우면 된다.



거리가 D이내면서, 가장 가까운 적의 위치 ti, tj를 찾는다

```
궁수의 위치를 a라고 한다.
0 0 0 0 0
0 0 0 0 0 
0 0 0 0 0
0 0 0 0 0
- - a - -
```



#### 적의 위치 탐색하기

1. BFS: BFS를 통해 가장 먼저 찾는 적이 가장 거리가 가까우면서 왼쪽에 있는 적이 된다.

2. 2차원 배열: 배열을 훑으면서 적을 발견한다. 

   ```python
   #비교할 변수 초기화
   ti, tj = -1, -1
   minD = D + 1
   
   for i in range(N):
       for j in range(M):
           #적 발견 & 궁수와의 거리가 D 이내이다.
           #a는 궁수의 위치이다. 
           if temp[i][j] == 1 and (abs(i-N) + abs(j-a)) <= d:
               #적의 최단거리 갱신
               if minD > abs(i-N) + abs(j-a):
                   minD = abs(i-N) + abs(j-a)
                   ti, tj = i, j
               #만약 최단거리가 같은데 적이 더 왼쪽에 있다면 바꿔야 한다.
               elif minD == abs(i-N) + abs(j-a) and j < tj:
                   ti, tj = i, j
   #적이 공격당했다는 점을 표시
   tmp[ti][tj] += 1 
   ```

3. 하나하나 위로 올라가고, 양옆으로 칸 수를 줄여가며 탐색하는 방법이 있다.
   - D 가 3이라면
   - 첫번째는 양옆으로 2칸을 살펴보고,
   - 그 위에는 양옆으로 1칸을 살펴보고,
   - 마지막으로 그 윗 줄에서는 중간칸을 살펴본다.



#### 다시 원상태로 돌려놓기

```python
tmp = [[0]*M for i in range(N)]
for i in range(N):
    for j in range(M):
        tmp[i][j] = enemy[i][j]
```





### 해설

https://github.com/pyjune 참고하기





## TIP

A형 검정 때  순열, 조합을 사용 시,  특정 숫자가 고정되는 경우가 많다.

A형 최근 유형

1. 문제의 앞 부분에서 조합, 순열, 부분집합을 많이 사용한다.
2. 문제의 뒷 부분에서는 완전탐색한다.
3. 1, 2번을 반복한다. (예를들어, 조합의 모든 경우의 수를 탐색할 때까지..)

주석으로 본인이 어떤 부분을 풀었는지 풀기

- 본인이 어떤 방식을 사용했는지 종이에다 그리고, 어떻게 코드를 정리할지 정의한 후, 코딩 시작하기.

